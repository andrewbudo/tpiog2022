001. Что определяет класс? Чем обличается класс от объекта?
002. Можно ли объявлять массив объектов? А массив классов?
003. Разрешается ли объявлять указатель на объект? А указатель на класс?
004. **Допускается ли передавать объекты в качестве параметров, и какими способами? А возвращать как результат?**  
Допускается по значению,  по ссылке и по указателю. Возвращать также можно значение, ссылку или указатель.
005. **Как называется использование объекта одного класса в качестве поля другого класса?**  
Композиция  
006. **Является ли структура классом? Чем класс отличается от структуры?**  
Является, у структуры все поля/методы по умолчанию public, у класса - private.  
007. **Какие ключевые слова в С++ обозначают класс?**  
struct, union, class  
008. **Объясните принцип инкапсуляции.**  
Инкапсуляция — в информатике, процесс разделения элементов абстракций, определяющих ее структуру (данные) и поведение (методы); инкапсуляция предназначена для изоляции контрактных обязательств абстракции (протокол/интерфейс) от их реализации.  
009. **Что такое композиция?**  
Композиция — строгий вариант агрегирования (методика создания нового класса из уже существующих классов путём их включения), когда включаемый объект может существовать только как часть контейнера. Если контейнер будет уничтожен, то и включённый объект тоже будет уничтожен.  
010. **Для чего используются ключевые слова public и private?**  
public и private (а так же protected) - модификаторы доступа.  
public – доступ открыт всем, кто видит определение данного класса.  
private – доступ открыт только для самого класса и друзьям (friend) данного класса.   
011. **Можно ли использовать ключевые слова public и private в структуре?**  
Да  
012. **Существуют ли ограничения на использование public и private в классе? А в структуре?**  
Нет  
013. Обязательно ли делать поля класса приватными?  
014. Что такое метод? Как вызывается метод?
015. Может ли метод быть приватный?
016. **Как определить метод непосредственно внутри класса? А вне класса? Чем эти определения отличаются?**  
```c++
// a)  
class A {
  int f(){return 0;}
}
```

```c++
// b)  
class A {
  int f();
}

int A::f(){return 0;}
```

Эти классы практически идентичны, но есть небольшое отличие. Определение первого класса эквивалентено:

```c++
// c)  
class A {
  int f();
}

inline int A::f(){return 0;}
```

То есть, оно отличается от второго наличием ключевого слова inline. Оно означает, что компилятор постарается (так как это не всегда возможно) заменить вызов этой функции его определением. Рекомендуется не использовать вариант a (желательно использовать эквивалентную запись), так как смешиваются "что делает класс" и "как это делает". 

017. **Можно в методах присваивать параметрам значения по умолчанию?**  
```c++
//Это можно сделать либо в объявлении класса:
class A { 
  int f(float c = 3.14);
}
//Либо при определении функции:
int A::f(float c = 3.14);
```
018. **Что обозначается ключевым словом this?**  
Ключевое слово this указывает на текущий экземпляр класса
019. Зачем нужны константные методы? Чем отличается определение константного метода от обычного?
020. Может ли константный метод вызываться для объектов-переменных? А обычный метод — для объектов-констант?
021. Объясните принцип полиморфизма.
022. Сколько места в памяти занимает объект класса? Как это узнать?
023. Каков размер «пустого» объекта?
024. Влияют ли методы на размер объекта?
025. **Одинаков ли размер класса и аналогичной структуры?**  
Да, одинаков.
026. **Какие операции нельзя перегружать? Как вы думаете, почему?**  
? : (тернарный оператор(операция, возвращающая свой второй или третий аргумент операции в зависимости от значения логического выражения, заданного первым операндом.);  
:: (доступ к вложенным именам);  
. (доступ к полям);  
. * (доступ к полям по указателю);  
Sizeof(управляет длиной переменной в скобках), typeid(возвращает ссылку на объект type_info, описывающий тип объекта).  
027. **Можно ли перегружать операции для встроенных типов данных?**  
Перегрузка расширяет возможности языка, а не изменяет язык, поэтому перегружать операторы для встроенных типов нельзя.  
028. **Можно ли при перегрузке изменить приоритет операции?**  
Нет, перегруженные операторы выполняются именно в порядке их приоритета.
029. **Можно ли определить новую операцию?**  
Нельзя. Технически это было бы несложно, но создало бы больше проблем, чем решило. Допустим, мы решили добавить операцию \*\*, означающую в некоторых языках возведение в степень. Посмотрим, какие возникают трудности:  
1) *Неоднозначность*. Как интерпретировать a\*\*b? (a)\*\*(b) или a\*(\*b). Оба варианта синтаксически корректны, но имеют разный смысл. Придется создавать правила для разрешения этой ситуации.  
2) *Ассоциативность*. Чему эквивалентно a\*\*b\*\*c? (a\*\*b)\*\*c или a\*\*(b\*\*c)?  
3) *Приоритет*. Чему эквивалентно a+b\*\*c? (a+b)\*\*c или a+(b\*\*c)? С точки зрения разработчика языка, проблемы не являются неразрешимыми. В некоторых языках есть такая возможность.
030. **Перечислите особенности перегрузки операций как методов класса. Чем отличается перегрузка внешним образом от перегрузки как метода класса?**   
1) Первый параметр метода класса опускается, им становится экземпляр класса (this).   
2) У метода класса имеется доступ к не-public членам.  
3) Метод класса можно сделать виртуальным. 
031. **Какой результат должны возвращать операции с присваиванием?**  
Ссылку на this 
032. **Как различаются перегруженная префиксная и постфиксная операции инкремента и декремента?**  
Префиксная(++a): T& operator++();  
Постфиксная(a++): T operator++(int); - с фейковым параметром чтобы как-то отличать
033. **Что означает выражение** \*this? **В каких случаях оно используется?**  
Разыменование указателя на текущий экземпляр. Например, чтобы вернуть объект.  
034. **Какие операции не рекомендуется перегружать как методы класса? Почему?**    
'Нужно перегружать только те, которые меняют private члены (+=, -= и т.д.). А вот уже +, - и т.д. - могут воспользоваться уже перегруженными +=, -=.  
Не рекомендуется перегружать ||, &&, так как по умолчанию они оптимальны - т.е. если установлена истинность одного аргумента, второй даже не обрабатывается.
035. **Какие операции разрешается перегружать только как методы класса?**    
=, [], (), ->    
036. **Дайте определение дружественной функции. Как объявляется дружественная функция? А как определяется?**    
Дружественная для данного класса функция - которой предоставлен доступ к private и protected членам. Функция объявляется внутри класса, к которому надо предоставить доступ, определяется там, где нужно (уже без модификатора friend).   
037. **Дайте определение конструктора. Каково назначение конструктора? Перечислите отличия конструктора от метода.**   
Конструктор - это особенный вид функции предназначенный для создания объкта(также является его назначением).  
Отличия - конструктор является особенным методом в классе, который хранит в себе заготовку для создания будущего объекта в отличии от метода в классе, который предназначен для выполнения какой-нибудь связи в классе.  

```cpp   
#include <iostream>
using namespace std;

class AB {
private:
    int a;
    int b;
public:
    //Конструктор должен быть того же имени, что и класс
    AB() {
        a = 0;
        b = 0;
        cout << "Созданный объект с переменными:" << endl;
        cout << "a = " << a << endl;
        cout << "b = " << b << endl;
    }
    
    void setAB() {
        cout << "Введите a: ";
        cin >> a;
        cout << "Введите b: ";
        cin >> b;
    }
    
    void getAB() {
        cout << "a = " << a << endl;
        cout << "b = " << b << endl;
    }
};

int main() {
    AB obj1; // создание объекта с помощью конструктора
    
    obj1.setAB();
    obj1.getAB();
}
```  
038. **Сколько конструкторов может быть в классе? Допускается ли перегрузка конструкторов? Какие виды конструкторов создаются по умолчанию?**    
Сколько угодно.  
Если контсруктор не объявляется, то компилятор предоставит неявный конструктор по умолчанию (не имеют параметров, но могут иметь значения по умолчанию). Также можно запретить компилятору использовать конструктор по умолчанию:  
```cpp
AB() = delete;
```
039. **Может ли конструктор быть приватным? Какие последствия влечет за собой объявление конструктора приватным?**    
Конструктор можно объявлять как приватный. Объект не сможет быть создан этим конструктором.  
040. Приведите несколько случаев, когда конструктор вызывается неявно.
041. Как проинициализировать динамическую переменную?
042. Как объявить константу в классе? Можно ли объявить дробную константу?
043. Каким образом разрешается инициализировать константные поля в классе?
044. В каком порядке инициализируются поля в классе? Совпадает ли этот порядок с порядком перечисления инициализаторов в списке инициализации конструктора?
045. Какие конструкции С++ разрешается использовать в списке инициализации качестве инициализирующих выражений?
046. Какой вид конструктора фактически является конструктором преобразования типов?
047. Для чего нужны функции преобразования? Как объявить такую функцию в классе?
048. Как запретить неявное преобразование типа, выполняемое конструктором инициализации?
049. Какие проблемы могут возникнуть при определении функций преобразования?
050. **Для чего служит ключевое слово explicit?**  
Ключевое слово explicit, примененное перед конструктором, делает так, что такой конструктор не может использоваться для неявных преобразованией типов.  
051. Влияет ли наличие целочисленных констант-полей на размер класса?
052. Разрешается ли объявлять массив в качестве поля класса. Как присвоить элементам массива начальные значения?
053. Сколько операндов имеет операция индексирования []? Какой вид результата должна возвращать эта операция?
054. Для чего нужны статические поля в классе? Как они определяются?
055. Как объявить в классе и проинициализировать статический константный массив?
056. Что такое выравнивание и от чего оно зависит? Влияет ли выравнивание на размер класса?
057. Дайте определение контейнера.  
058. **Какие виды встроенных контейнеров в С++ вы знаете?**  
Sequences               : vector, list, deque, queue, stack  
Associative containers  : map, set, multimap, multiset  
Other                   : priority_queue, bitset  
059. **Какие виды доступа к элементам контейнера вам известны?**  
Разыменование итератора, оператор индексирования.  
060. **Чем отличается прямой доступ от ассоциативного?**  
*Прямой доступ* к элементу — это доступ по номеру (или, еще говорят, по индексу) элемента.  
*Ассоциативный доступ* похож на прямой, однако основан не на номерах элементов, а на содержимом элементов контейнера.  
061. **Перечислите операции, которые обычно реализуются для последовательного доступа к элементам контейнера.**  
- \+	Объединение элементов  
- +=	Добавление элементов в контейнер  
- <<	Добавление элемента в контейнер  
- at()	Доступ к произвольному элементу  
- front() и first()	Предоставляют ссылку на первый элемент в предположении, что он существует. Использование метода front() предпочтительнее по стандарту STL.  
- back() и last()	Предоставляют ссылку на последний элемент в предположении, что он существует. Использование метода back() предпочтительнее по стандарту STL.  
- contains()	Проверка контейнера на наличие переданного элемента  
- erase()	Удаляет элемент, на который указывает параметр-итератор  
- IndexOf()	Возвращает индекс первого элемента, который соответствует значению переданного параметра 
- pop_front()	Удаляет из контейнера первый элемент  
- pop_back()	Удаляет из контейнера последний элемент  
- replace()	Заменяет значение элемент контейнера на значение своего параметра  
- push_front() и prepend()	Добавляют элемент в начало контейнера. Использование метода push_front() предпочтительнее по стандарту STL.  
- push_back() и append()	Добавляют элемент в конец контейнера. Использование метода push_back() предпочтительнее по стандарту STL.  
062. **Дайте определение итератора.**  
Итератор (от англ. iterator ― перечислитель) — интерфейс, предоставляющий доступ к элементам коллекции (массива или контейнера) и навигацию по ним.  
063. **Можно ли реализовать последовательный доступ без итератора? В чем преимущества реализации последовательного доступа с помощью итератора?**  
Да. Единообразная работа с различными сущностями.  
064. Что играет роль итератора для массивов С++?
065. Что такое деструктор? Может ли деструктор иметь параметры?
066. Почему для классов-контейнеров деструктор надо писать явным образом?
067. Допускается ли перегрузка деструкторов?
068. **Что такое «глубокое копирование» и когда в нем возникает необходимость?**    
Если копируется объект, в котором есть поле-указатель, надо скопировать объект, на который указывает тот указатель, а не просто указатель.
069. **Какое копирование осуществляет стандартный конструктор копирования?**   
Копируются все поля.   
070. **Чем отличается копирование от присваивания?**    
Копирование - инициализация объектом того же типа. Присваивание - замена уже существующего объекта.   
071. Объясните, почему в операции присваивания требуется проверка присваивания самому себе?
072. Можно ли в качестве операции индексирования использовать операцию вызова функции ()? В чем ее преимущества перед операцией []?
073. Почему необходимо писать два определения операции индексирования? Чем они отличаются?
074. Дайте определение вложенного класса.
075. Можно ли класс-итератор реализовать как внешний класс? А как вложенный? В чем отличия этих методов реализации?
076. Может ли объемлющий класс иметь неограниченный доступ к элементам вложенного класса? А вложенный класс — к элементам объемлющего?
077. Ограничена ли глубина вложенности классов?
078. Можно ли определить вложенный класс внешним образом? Зачем это может понадобиться?
079. Каким образом вложенный класс может использовать методы объемлющего класса? А объемлющий — методы вложенного?
080. **Что такое «запредельный» элемент, какую роль он играет в контейнерах?**  
В стандартных контейнерах это end(), используется для обозначения конца контейнера, возвращения в случае неудачного поиска, и т.д.  
081. **Объясните, по каким причинам трудно написать универсальный контейнер, элементы которого могут иметь произвольный тип.**  
Из-за строгой типизации (нужен либо VARIANT, либо dynamic_cast).  
082. **Назовите ключевые слова С++, которые используются для обработки исключений.**  
try (пытаться) - начало блока исключений;  
catch (поймать) - начало блока, "ловящего" исключение;  
throw (бросить) - ключевое слово, "создающее" ("возбуждающее") исключение  
083. **Исключение — это: 1) событие; 2) ситуация; 3) объект; 4) ошибка в программе; 5) прерывание;**  
Правильный ответ 1) событие  
084. **Каким образом исключение генерируется?**  
Обычно система сама генерирует исключения при определенных ситуациях, например, при делении числа на ноль. Но язык C++ также позволяет генерировать исключения вручную с помощью оператора throw. То есть с помощью этого оператора мы сами можем создать исключение и вызвать его в процессе выполнения.  
085. **Каковы функции контролируемого блока?**  
Отловить исключения которые сгенерированы внутри него  
086. **Что обозначается ключевым словом catch? 1) контролируемый блок; 2) блок обработки исключения; 3) секция-ловушка; 4) генератор исключения; 5) обработчик прерывания;**  
Ответ: 2.  
Пояснения:
1) контролируемый блок;        (try-catch)
2) блок обработки исключения;  (catch)
3) секция-ловушка;              (try)
4) генератор исключения;        (throw)
5) обработчик прерывания;      (try-catch)
087. **Какого типа может быть исключение?**  
Кроме типа exception в C++ есть еще несколько производных типов исключений, которые могут использоваться при различных ситуациях. Основные из них:  
* *runtime_error*: общий тип исключений, которые возникают во время выполнения
* *range_error*: исключение, которое возникает, когда полученный результат превосходит допустимый диапазон
* *overflow_error*: исключение, которое возникает, если полученный результат превышает допустимый диапазон
* *underflow_error*: исключение, которое возникает, если полученный в вычислениях результат имеет недопустимые отрицательное значение (выход за нижнюю допустимую границу значений)
* *logic_error*: исключение, которое возникает при наличии логических ошбок к коде программы
* *domain_error*: исключение, которое возникает, если для некоторого значения, передаваемого в функцию, не определено результата
* *invalid_argument*: исключение, которое возникает при передаче в функцию некорректного аргумента
* *length_error*: исключение, которое возникает при попытке создать объект большего размера, чем допустим для данного типа
* *out_of_range*: исключение, которое возникает при попытке доступа к элементам вне допустимого диапазона
088. Сколько параметров разрешается писать в заголовке секции-ловушки?
089. Какими способами разрешается передавать исключение в блок обработки?
090. Объясните, каким образом преодолеть ограничение на передачу единственного параметра в блок обработки.
091. **Почему нельзя выполнять преобразования типов исключений при передаче в секцию-ловушку?**  
Из-за того, что catch-блок хранит в себе лишь информацию о конкретных типах   
092. **Напишите конструкцию, которая позволяет перехватить любое исключение.**   
```c++
try {
    //инструкции, которые могут вызвать исключения
} catch(...) {
    //обработка исключений
}
```
093. **Могут ли контролируемые блоки быть вложенными?**   
Могут:   
```c++
try
  {
    try
    {
      compare(j); // Вложенный контролируемый блок
    }
    catch (int n)
    {
      cout << "\nOdd";
      throw;           
    }
    catch (const char *)
    {
      cout << "\nEven"; 
    }
  } // Конец внешнего контролируемого блока
  catch (int i)
  {
    cout " "\nResult = " << i;
  }
}
```
094. Зачем нужен «контролируемый блок-функция» и чем он отличается от обычного контролируемого блока?
095. Перечислите возможные способы выхода из блока обработки.
096. Каким образом исключение «передать дальше»?
097. Сколько секций-ловушек должно быть задано в контролируемом блоке?
098. Что такое «спецификация исключений»?
099. Что происходит, если функция нарушает спецификацию исключений?
100. Учитывается ли спецификация исключений при перегрузке функций?
101. Что такое «иерархия исключений»?
102. Существуют ли стандартные исключения? Назовите два-три типа стандартных исключений.
103. Поясните «взаимоотношение» исключений и деструкторов.
104. Объясните, зачем может понадобиться подмена стандартных функций завершения.
105. Какие виды нестандартных исключений вы знаете?
106. В чем отличие механизма структурной обработки исключений Windows от стандартного механизма?
107. Какие две роли выполняет наследование?
108. Какие виды наследования возможны в С++?
109. Чем отличается модификатор доступа protected от модификаторов private и public?
110. Чем открытое наследование отличается от закрытого и защищенного?
111. Какие функции не наследуются?
112. Сформулируйте правила написания конструкторов в производном классе.
113. Каков порядок вызова конструкторов? А деструкторов?
114. Можно ли в производном классе объявлять новые поля? А методы?
115. Если имя нового поля совпадает с именем унаследованного, то каким образом разрешить конфликт имен?
116. Что происходит, если имя метода-наследника совпадает с именем базового метода?
117. Сформулируйте принцип подстановки.
118. Когда выполняется понижающее приведение типов?
119. Объясните, что такое «срезка» или «расщепление».
120. Объясните, зачем нужны виртуальные функции.
121. Что такое связывание?
122. Чем «раннее» связывание отличается от «позднего»?
123. Какие два вида полиморфизма реализованы в С++?
124. Дайте определение полиморфного класса.
125. Может ли виртуальная функция быть дружественной функцией класса?
126. Наследуются ли виртуальные функции?
127. Каковы особенности вызова виртуальных функций в конструкторах и деструкторах?
128. Можно ли сделать виртуальной перегруженную операцию, например, сложение?
129. Может ли конструктор быть виртуальным? А деструктор?
130. Как виртуальные функции влияют на размер класса?
131. Как объявляется «чистая» виртуальная функция?
132. Дайте определение абстрактного класса.
133. Наследуются ли чистые виртуальные функции?
134. Можно ли объявить деструктор чисто виртуальным?
135. Чем отличается чистый виртуальный деструктор от чистой виртуальной функции?
136. Зачем требуется определение чистого виртуального деструктора?
137. Наследуется ли определение чистой виртуальной функции?
138. Приведите классификацию целей наследования.
139. Объясните разницу наследования интерфейса от наследования реализации.
140. Назовите причины, требующие разделения программ на части.
141. Дайте определение термина «единица трансляции»?
```
(Transalation unit)
Исходный файл (cpp, cxx, C, ...) c подключенными заголовочными файлами
и другими файлами подключенными с помощью include.
```
143. Чем отличается файл с исходным текстом от единицы трансляции?
```
Файл с исходным текстом не обязательно является единицей трансляции.
```
145. Существуют ли в С++ конструкции, позволяющие идентифицировать отдельный модуль?
146. Какие способы сборки программы вы можете назвать?
147. Что такое «объектный модуль»? Программа, которая «собирает» объектные модули в программу, называется _____________ ?
148. В чем заключается отличие аргумента «файл» от <файл> в директиве #include?
```
Локальные и глобальные инклуды (т.е. логическое разделение).
Отличается тем где компилятор пытается найти подключаемый файл в первую очередь.
```
150. Что такое ODR?
```
One Definition Rule (Правило Одного Определения).
```
152. Объясните, что такое «страж» включения и зачем он нужен.
154. Является ли интерфейс класса его определением?
```
Да.
```
156. Сколько определений класса может быть в единице трансляции?
```
Одно.
```
158. Сколько определений класса может быть в многофайловой программе?
159. Чем отличаются стандартные заголовки <string>, <string.h> и <cstring>?
160. Объясните суть идиомы Pimpl.
161. Что такое делегирование и как его можно использовать для повышения степени инкапсуляции?
162. Каким образом глобальную переменную, определенную в одной единице трансляции, сделать доступной в другой единице трансляции? А константу?
163. Можно ли использовать слово extern при объявлении функций?
164. Как локализовать объявление функции в файле?
165. Чем отличается «внешнее» связывание от «внутреннего» связывания?
166. Что такое «спецификации компоновки»?
167. Какие объекты обладают внутренним связыванием по умолчанию?
168. Какие области видимости имен вы знаете?
169. Для чего используются пространства имен?
170. Чем отличаются именованные и неименованные пространства имен?
171. Могут ли пространства имен быть вложенными?
172. Для чего применяются алиасы пространства имен?
```
Для удобства. Для избежания конфликтов имен.
```
173. Как сделать члены пространства имен доступными в нескольких (в пределе — во всех) файлах программного проекта?
174. Объясните разницу между статической и динамической инициализацией.
175. В чем состоит проблема инициализации глобальных статических переменных?
176. Какие элементы класса можно объявлять статическими?
177. Можно ли объявить в классе статическую константу? А константный статический массив?
178. А какие статические поля можно инициализировать непосредственно в классе?
179. Как определяются статические поля? В какой момент работы программы выполняется инициализация статических полей?
180. Сколько места в классе занимают статические поля ?
181. Чем отличается статический метод от обычного?
182. Какие методы класса не могут быть статическими?
183. Какие применения статических полей вы можете привести? А каким образом применяются статические методы?
184. Приведите структуру и принцип действия паттерна Singleton.
185. Для чего предназначены шаблоны?
186. Какие виды шаблонов в С++ вы знаете?
187. Объясните термин «инстанцирование шаблона».
188. В чем разница между определением и объявлением шаблона?
189. Объясните назначение ключевого слова typename.
190. Какие виды параметров разрешается задавать в шаблоне класса? А в шаблоне функции?
191. Можно ли параметрам шаблона присваивать значения по умолчанию?
192. Может ли параметром шаблона быть другой шаблон? Каковы особенности объявления параметра-шаблона?
193. Что такое специализация шаблона? Объясните разницу между полной и частичной специализацией.
194. Разрешается ли специализировать шаблон функции?
195. Может ли класс-шаблон быть вложенным в другой класс-шаблон? А в обычный класс?
196. Можно ли объявить в классе шаблонный метод? А шаблонный конструктор?
197. Можно ли перегружать функцию-шаблон?
198. Какие параметры функции-шаблона выводятся автоматически?
199. Может ли шаблон класса быть наследником обычного класса? А обычный класс от шаблона?
200. Объясните, что такое класс свойств (класс трактовок).
201. Каким образом можно использовать возможность наследования обычного класса от шаблона?
202. Может ли шаблонный конструктор быть конструктором по умолчанию?
203. Для чего применяются директивы явного инстанцирования?
204. Объясните, в чем состоят проблемы, возникающие при разделении шаблонного класса на интерфейс и реализацию?
205. Что такое «модель явного инстанцирования» и как она работает?
206. Может ли шаблонный класс иметь «друзей»?
207. Какие проблемы возникают при объявлении дружественной функции для класса-шаблона?
208. Разрешается ли определять в классе-шаблоне статические поля? А статические методы?
209. Что такое «инициализация нулем»?
210. Что является единицей памяти в С++? Какие требования к размеру единицы памяти прописаны в стандарте С++?
211. В каких единицах выдает результат операция sizeof? Какие типы данных имеют размер 1?
212. Какие три вида памяти входят в модель памяти С++?
213. Сколько видов динамической памяти обеспечивает С++?
214. Какие функции для работы с динамической памятью достались С++ по наследству от С? В какую библиотеку они включены?
215. Какие функции выделяют память, и с помощью каких функций память освобождается?
216. Какое важное отличие имеет функция calloc() от функции malloc()?
217. Какие действия выполняют функции выделения памяти, если память не может быть выделена?
218. Зависит ли объем выделенной памяти от типа указателя? Влияет ли выравнивание на объем выделяемой динамической памяти?
219. Можно ли с помощью функции realloc() уменьшить объем выделенной памяти?
220. Что произойдет, если функции free() передать в качестве аргумента нулевой указатель?
221. В чем главное отличие объектно-ориентированного механизма new/delete от механизма malloc()/free()?
222. Сколько существует форм new/delete? В чем их отличие?
223. Какие типы являются POD-типами? Чем отличается работа механизма new/delete с POD-объектами и nonPOD-объектами?
224. Какие функции выполняет обработчик new?
225. Можно ли реализовать собственный обработчик new и «прицепить» его к механизму new/delete?
226. В чем главное отличие объединения от других видов классов С++?
227. Может ли объединение участвовать в иерархии наследования?
228. Разрешается ли определять для объединения конструкторы и деструктор? А виртуальные функции?
229. В чем похожи и чем отличаются объединение и размещающий new?
230. Объясните, почему при использовании размещающего new нужно явным образом вызывать деструктор?
231. Зачем нужны интеллектуальные указатели?
232. Что такое «стратегия владения»? Сколько стратегий владения вы знаете?
233. Какой интеллектуальный указатель реализован в стандартной библиотеке STL, и какую стратегию владения он реализует?
234. Объясните, в чем преимущества и недостатки интеллектуальных указателей со счетчиком ссылок.
235. Разрешается ли перегружать new и delete и какими способами?
236. Опишите схему функции, перегружающей глобальную функцию new.
237. Отличается ли реализация перегруженной функции new[]() для массивов от реализации «обычной» функции new()?
238. Как вы думаете, почему функции new/delete, перегружаемые для класса, являются статическими?
239. Зачем при перегрузке new/delete для класса нужно проверять размер запрашиваемой памяти?
240. Объясните, чем определяется «динамичность» контейнеров?
241. Что такое «стратегия распределения памяти», и какие стратегии выделения памяти вы знаете?
242. Рассмотрите следующую стратегию распределения памяти: память выделяется для нескольких элементов блоками фиксированной длины, но блоки связываются в список. Для какого вида контейнера можно использовать такую стратегию?
243. Какие операции можно перегрузить для доступа к элементам двумерного массива?
244. В чем заключаются сложности использования операции индексирования [] для доступа к элементам двумерного массива?
245. Каковы способы реализации операций с контейнерами?
246. Какую конструкцию можно назвать «обобщенный алгоритм»?
247. Каким образом объявить указатель на метод?
248. Объясните разницу между указателем на функцию и указателем на метод.
249. Каким образом получить адрес метода?
250. Можно ли указателю на функцию присваивать адрес метода?
251. Какие операции определены в С++ для косвенного вызова метода через указатель?
252. Что такое «функтор»? Приведите пример функционального класса.
253. Какими способами функтор вызывается?
254. Можно ли использовать наследование при разработке функторов?
255. Разрешается ли операцию вызова функции () определять как виртуальный метод? А как статический?
256. В чем преимущества функторов перед указателями на функции?
257. Объясните, зачем нужны адаптеры функторов? Какие виды адаптеров вы знаете?
258. Как используются классы свойств при разработке функторов?
259. Объясните, что такое «композиция» и приведите примеры?
260. Объясните, чем отличается множественное наследование от простого?
261. Приведите структуру и принцип действия паттерна Adapter.
262. Сформулируйте основную проблему множественного наследования.
263. Выполняется ли принцип подстановки при открытом множественном наследовании?
264. Что такое виртуальное наследование? Каковы его преимущества и недостатки по сравнению с обычным наследованием?
265. Может ли виртуальное наследование быть одиночным?
266. Влияет ли виртуальное наследование на размер класса?
267. Объясните, каким образом с помощью виртуального наследования можно вообще запретить наследование.
268. Какие средства С++ составляют RTTI?
269. Объясните разницу между повышающим, понижающим и перекрестным приведением.
270. Какими свойствами должен обладать класс, чтобы с ним работал механизм RTTI?
271. В чем приведение указателей отличается от приведения ссылок?
272. Какие исключения связаны с механизмом RTTI?
273. Что такое «поток» — дайте определение.
274. Как классифицируются потоки, реализованые в библиотеках ввода/вывода С++?
275. Что такое буферизация и зачем она нужна?
276. Какие библиотеки ввода/вывода реализованы в С++ и чем они отличаются?
277. Перечислите стандартные потоки и объясните их назначение.
278. Зачем нужен процесс форматирования и когда он выполняется?
279. Что такое «форматная строка», и в каких функциях она используется?
280. Объясните назначение элементов спецификатора формата.
281. Сколько спецификаторов формата может быть в форматной строке?
282. Какой из элементов спецификатора формата не является умалчиваемым?
283. Перечислите несколько известных вам обозначений типов в спецификаторе формата, и укажите их назначение.
284. Сколько модификаторов типа вы знаете, и какую роль модификатор типа играет в спецификаторе формата?
285. С помощью какого флага можно выровнять выводимое значение влево? А каким образом вывести ведущие нули?
286. Какое действие оказывают на выводимую строку ширина, точнойть и флаги в спецификаторе формата?
287. Для чего в спецификаторе формата может использоваться символ звездочка («\*»)? Чем отличается действие этого символа при воде и при выводе?
288. Каковы особенности ввода строк?
289. Каким образом ограничить набор вводимых символов при вводе?
290. Что является главной проблемой при использовании форматного ввода/вывода из библиотеки <cstdio>?
291. Объясните, для чего нужны строковые потоки. Почему строковые потоки —всегда форматируемые?
292. С помощью каких функций выполняется работа со строковыми потоками?
293. Можно ли использовать тип string (и каким образом) со строковыми потоками?
294. Объясните, в чем заключается различие между текстовым и двоичным файлом.
295. Объясните, что означает «открыть» файл и «закрыть» файл?
296. Каким образом внешний файл связывается с потоком?
297. Можно ли один и тот же поток связать с разными файлами? А один и тот же файл с разными потоками?
298. Перечислите режимы открытия файла. Чем отличается режим “r” от режима “a”?
299. Какую роль в режиме открытия играет знак плюс («+»)?
300. В каких случаях необходимо следить за ситуацией «конец файла»? Каким способом это делается?
301. Можно ли текстовый файл открыть как двоичный? А двоичный — как текстовый?
302. Какие функции ввода/вывода используются для обмена с текстовыми файлами?
303. Перечислите функции ввода/вывода для работы с двоичными файлами.
304. Какие функции реализованы в библиотеке <cstdio> для обеспечения прямого доступа к записям двоичного файла? Можно ли их использовать для работы с текстовыми файлами?
305. Объясните назначение функции fseek().
306. Чем отличается функция ftell() от функции fgetpos()?
307. Объясните, что означает «перенаправление» потока? Какие потоки можно перенаправлять и куда?
308. Каким образом перенаправление ввода можно использовать для ввода строк с пробелами?
309. В чем преимущества объектно-ориентированной библитеки по сравнению с процедурной?
310. В каких состояних может находиться поток? Каким образом отслживается состояние «конец потока»?
311. Какие объектно-ориентированные потоки связаны со стандартными потоками?
312. Чем отличаются объектно-ориентированные строковые потоки от процедурных строковых потоков?
313. Каким образом строковые потоки можно использовать для ограничения ширины поля ввода? А можно ли с той же целью использовать строковые потоки <cstdio>?
314. Сравните средства форматирования объектно-ориентированной и процедурной библиотеки.
315. Каким образом ввести строку типа string с пробелами?
316. Каково назначение флагов форматированя? Какие средства реализованы в библиотеке для работы с флагами форматирования?
317. Что такое «манипулятор»? В чем преимущества манипуляторов перед флагами форматирования?
318. Как связываются файлы с потоками в объектно-ориентированной библиотеке?
319. Можно ли файлы, записанные функциями библиотеки <cstdio>, прочитать объектно-ориентированными средствами? А наоборот?
320. Перечислите режимы открытия объектно-ориентированных файловых потоков. каким образом комбинируются режимы открытия файлоавых потоков?
321. Обязательно ли закрывать файл, связанный с объектно-ориентированным файловым потоком? А открывать?
322. Каким образом открыть файловый поток для чтения и записи одновременно?
323. Как открыть файловый поток для дозаписи?
324. Можно ли вывести значение переменной в двоичном виде и как это сделать?
325. Разрешается ли наследовать от классов библиотеки ввода/вывода?
326. Каким образом можно еренаправить объектно-ориентированный поток?
327. Как используется буфер потока для копирования потока?
328. Какими операциями выполняется форматированный ввод/вывод в файловые потоки? А неформатированный?
329. Реализованы ли в объектно-ориентированной библиотеке средства прямого доступа к файловым потокам? Сравните их с аналогичными средствами библиотеки <cstdio>.
330. С какими объектно-ориентированными потоками разрешается, и с какими не разрешается использовать средства прямого доступа?
331. Покажите, каким образом можно выполнить перегрузку операций ввода/вывода для нового типа данных.
332. Как выполняется обработка ошибок ввода/вывода в объектно-ориентированной библиотеке?
333. Какое стандартное исключение генерируется при ошибках ввода/вывода? Обязательно ли оно генерируется?
334. Чем стандартные широкие потоки отличаются от узких?
335. Что такое — «локаль», и каково ее назначение?
336. Как установить русский шрифт при выводе в консольное окно?
337. Чем отличается ли ввод/вывод широких файловых потоков от узких?
338. Перечислите все последовательные контейнеры стандартной библиотеки. Чем они отличаются друг от друга?
339. Перечислите адаптеры последовательных контейнеров и дайте их подробную характеристику.
340. Почему для адаптеров-очередей нельзя использовать вектор в качестве базового?
341. Чем простая очередь queue отличается от приоритетной очереди priority_queue?
342. Каким требованиям должны удовлетворять элементы контейнера?
343. Могут ли быть указатели элементами контейнера? А итераторы?
344. Почему нельзя использовать в качестве элементов контейнера стандартный интеллектуальный указатель auto_ptr?
345. Зачем в контейнере list реализованы собственные методы сортировки поиска и слияния? Можно ли пользоваться соответствующими стандартными алгоритмами при обработке списка?
346. Перечислите типовые виды конструкторов, с помощью которых можно создавать последовательный контейнер.
347. Можно ли инициализировать контейнер элементами встроенного массива? А элементами другого контейнера? Какими способами это можно сделать?
348. Почему конструктор инициализации, параметрами которого являются итераторы, сделан шаблонным во всех контейнерах?
349. Какие методы реализованы в контейнере-векторе для доступа к элементам?
350. Отличается ли функция at() доступа по индексу от перегруженной операции индексирования и чем?
351. Перечислите методы контейнера deque, относящиеся к определению размеров контейнера.
352. Чем метод size() отличается от метода capacity()? А в чем отличие этих методов от метода max_size()?
353. Перечислите методы контейнера list, предназначенные для вставки удаления и замены элементов. Отличаются ли эти методы от соответствующих методов вектора и дека?
354. Каким образом выполняются операции сравнения контейнеров?
355. Разрешается ли изменять элемент ассоциативного контейнера, доступный в данный момент по итератору?
356. Какие контейнеры называются ассоциативными и почему?
357. Чем контейнер map отличается от контейнера multimap?
358. Объясните, почему в ассоциативных контейнерах нельзя изменять элемент, доступный в данный момент по итератору.
359. По каким причинам в контейнере-множестве не реализованы типовые операции объединения, пересечения, разности и другие?
360. Как используется структура-пара в ассоциативных контейнерах?
361. Объясните, что такое «критерий сортировки», и каким требованиям он должен удовлетворять? Какой критерий сортировки принят по умолчанию?
362. Какими преимуществами обладает функция make_pair() по сравнению с конструктором pair()?
363. Почему в контейнерах-отображениях операция индексирования перегружена, а в контейнерах-множествах — нет?
364. Какие гарантии безопасности обеспечивают контейнеры стандартной библиотеки?
365. Что такое «транзакционная гарантия безопасности» и чем она отличается от базовой?
366. На какие 4 класса по надежности можно разделить все операции с контейнерами?
367. Что такое «распределитель памяти» и зачем он нужен?
368. Чем отличается битовый вектор bitset от битового вектора vector<bool>?
369. Дайте определение итератора.
370. Что такое «начальный» итератор и «конечный» итератор? Какие методы, связанные с итераторами, обязательно включает каждый контейнер?
371. Чем константный итератор отличается от неконстантного?
372. Объясните, что такое «недействительный» итератор. В каких случаях итераторы становятся недействительными?
373. Какие категории итераторов вы знаете? Какие операции обязательно реализуются для всех категорий итераторов?
374. К какому виду итераторов можно отнести встроенный указатель и почему?
375. Какие вспомогательные функции для итераторов вы знаете? В каких случаях оправдано их применение?
376. Какие адаптеры итераторов реализованы в библиотеке?
377. Объясните, почему итераторы реализованы как вложенные классы в контейнерах.
378. Чем отличаются итераторы вставки от обычных итераторов?
379. Каким образом используются потоковые итераторы?
380. Какие стандартные функторы реализованы в библиотеке STL? Каково их основное назначение?
381. Для чего нужны адаптеры функторов bind1st() и bind2nd()?
382. Как применяются адаптеры-отрицатели?
383. Почему алгоритмы remove() не удаляют элементы из контейнеров? Как реально удалить элементы из контейнера?
384. Чем отличается стабильная сортировка от обычной?
385. Какую функцию выполняет алгоритмы unique()?
386. Могут ли стандартные алгоритмы работать со строками?
387. Нужно ли сортировать ассоциативные контейнеры?
388. Можно ли алгоритмы для работы с множествами применять для последовательных контейнеров? При каких условиях?
389. Какие алгоритмы предназначены для заполнения контейнера значениями? С какими контейнерами они могут работать?
390. Каким образом заполнить с помощью алгоритма generate() последовательный контейнер, не имеющий ни одного элемента?
391. Перечислите алгоритмы, предназначенные для операций с каждым элементом контейнера.
392. Можно ли с помощью алгоритма for_each() изменить элементы контейнера?
393. В чем заключаются основные принципы ООП?
394. Что такое сложность алгоритма?
395. Код работает неправильно. Что делать?
396. Объясните такие структуры данных, как стек и очередь.
397. Какие книги, связанные с программированием, вы читали? Что почерпнули для себя?
398. Что интересного нашли в новых стандартах С++ 17 С++ 20?
399. Что такое таблица ASCII?
400. Что такое Unicode?
401. Что такое паттерны проектирования и для чего их используют?
402. Паттерны Singleton, Strategy, Template-Method, Decorator?
403. Для чего нужны модульные тесты?
404. Как разница между модульными и интеграционными тестами?
405. Что такое TDD?
406. Что такое шаблонный класс и шаблонная функция?
407. Что такое конструкторы? Какие типы вы знаете?
408. Может ли конструктор быть шаблонной функцией?
409. Может ли виртуальная функция быть шаблонной?
410. Что такое инстанциация шаблона?
411. Что такое специализация шаблона? Частичная специализация шаблона?
412. Расскажите об имплементации шаблонных классов в срр-файле.
413. Как проходит процесс компиляции срр-файлов в бинарный файл?
414. Что такое препроцессор?
415. Как работает препроцессор?
416. Какие знаете его команды?
417. Как работает директива include?
418. Как работает директива define?
419. Что именно линкует линкер?
420. Что такое оптимизация компилятора?
421. Что такое флажки компиляции?
422. Как защитить хедер от повторного включения?
423. Что делает директива include?
424. Как работают макросы?
425. Как static влияет на глобальные / локальные переменные?
426. Как сonst влияет на переменную?
427. Какие варианты использования extern вы знаете?
428. Какие варианты использования volatile вы знаете?
429. Какие есть битовые операции?
430. Что такое булева алгебра?
431. Расскажите об этапах разработки библиотеки или программы.
432. Что такое алгоритмы сортировки и какие вы знаете?
433. Какие алгоритмы работы со строками знаете?
434. Какие алгоритмы на графах знаете?
435. Где может храниться переменная?
436. Какая разница между calloc и malloc?
437. Для чего используют realloc?
438. Что такое указатель?
439. Какой размер имеет указатель и от чего он зависит?
440. Какие есть операции с указателями?
441. Что такое struct?
442. Как определить размер структур?
443. Что такое выравнивание в структурах?
444. Что такое union?
445. Каков размер union?
446. Что такое класс?
447. Какие основные типы данных в C++?
448. Что такое инкапсуляция? Как она реализуется в C++?
449. Какие есть встроенные типы в С++?
450. Что такое enum?
451. Как соотносится класс и объект?
452. Какая разница между структурой и классом?
453. В чем разница между private / protected / public и где они используются?
454. Какие методы класса являются стандартными для класса?
455. Что такое абстрактный класс и зачем он нужен?
456. Сколько занимает памяти объект пустой класс class A{}; ?
457. Что станет с функцией, если к ней добавить ключевое слово static? В контексте члена класса? В контексте метода класса?
458. Какие особенности статических полей класса?
459. В чем особенность константных методов-членов класса?
460. Как изменить поле класса в константном методе класса?
461. Какие методы можно вызвать из константных объектов?
462. Что такое куча и стек? Различия, принцип работы.
463. В чем разница между указателем и ссылкой?
464. Для чего нужен указатель на функцию? Как его объявить?
465. Что будет, если забыть вызвать delete? Когда освободится та память?
466. Что такое умный указатель? Какие умные указатели есть в стандартной библиотеке?
467. Как работает std::unique_ptr?
468. Как работает std::shared_ptr?
469. Расскажите о константности переменной, ссылки, указателя. Что такое константный указатель и указатель на константу? Размер указателя в памяти?
470. Расскажите о передаче аргументов по значению, ссылке и указателю.
471. Расскажите о порядке вычисления аргументов функции.
472. Что случится, если вернуть ссылку на временный объект?
473. Что такое перегрузка функции? Виды перегрузки.
474. Что такое явное и неявное приведение типов в С++? Расскажите о функциях явного приведения типов в C++.
475. Что такое инициализация переменной в if?
476. Что такое ленивые вычисления в С++?
477. Расскажите о циклах for и range-for.
478. Что делает ключевое слово auto? auto-определение return-типа, аргументов функции?
479. Чем отличаются delete и delete[]? Что случится, если вызвать delete у объекта, созданного через new[]?
480. Обработка ошибок в С++. Какие конструкции используют при обработке exception?
481. Можно ли выбрасывать exception из конструктора? Какие поля будут сконструированы, какие поля будут разрушены?
482. Что такое memory leak?
483. Можно ли выбрасывать exception с деструктора?
484. Как отловить деление на 0 в С++?
485. Как работают константные методы?
486. Что такое лямбда-функция в С++? Как получить доступ к переменным во внешней области видимости?
487. Для чего использовать namespace, anonymous namespace?
488. Как вызвать объект с nested namespace?
489. Как работают inline-функции? Может ли такая функция быть рекурсивной?
490. Что такое полиморфизм?
491. Для чего используется наследование?
492. Какие бывают типы наследования?
493. Для чего используют виртуальное наследование?
494. Как можно решить проблему ромбовидного наследования без использования виртуального наследования?
495. Что случится, если класс-наследник передать по значению в функцию, которая принимает базовый класс?
496. Что случится, если унаследоваться от базового класса, не имеющего виртуального конструктора?
497. Что случится, если вызвать переопределенную virtual function из конструктора? Может конструктор быть виртуальным?
498. Может ли иметь имплементацию pure virtual function? Что случится, если вызвать pure virtual function из конструктора?
499. Какие методы генерируются для класса по умолчанию? В каком случае такие методы не будут генерироваться? Как заставить компилятор добавить / удалить эти методы?
500. Как запретить наследовать класс?
501. Каков порядок конструирования и разрушения классов в иерархии? Порядок инициализации полей класса?
502. Какие есть способы инициализации полей класса?
503. Может ли деструктор быть виртуальным?
504. Что делает ключевое слово virtual?
505. Для чего используют виртуальный деструктор?
506. Что такое глубокое копирование?
507. Что такое виртуальные функции и зачем они нужны?
508. Как защитить объект от копирования?
509. Что такое семантика перемещения?
510. Из чего состоит STL?
511. Какие алгоритмы применяли с STL? В чем преимущество использования алгоритмов перед собственноручно написанными функциями?
512. Расскажите о контейнерах стандартной библиотеки vector, list, map, unordered_map.
513. Какие знаете типы итераторов? Чем они отличаются? В каких контейнерах используются?
514. Какая разница между std::set, std::map std::unordered_multimap?
515. Что такое идиома remove-erase?
516. Как получить наименьшее значение типа?
517. Какая разница между std::map и std::hashmap?
518. Как подсчитать количество элементов в std::list?
519. Что такое сложность алгоритма и от чего она зависит?
520. В чем разница между vector и list и в каких случаях их лучше использовать?
521. Что вам известно о многопоточности?
522. Что общего и отличного в процессах и потоках?
523. Как синхронизировать передачи информации между потоками?
524. Какая разница между мьютекс и семафором?
525. Что такое deadlock?
526. Является ли С++ thread-safe?
527. Что такое race-condition?
528. Как избежать состояния гонки?
529. Что такое атомарная операция?
530. Как работать с std::mutex?
531. Что такое сокет?
532. Какие операции можно делать с сокетом?
533. Какая информация нужна, чтобы создать сокет?
534. Какие бывают модели сетей?
535. Расскажите об уровнях модели OSI.
536. Расскажите об уровнях модели TCP/IP.
537. Что такое IP-адрес?
538. Для чего используется маска подсети?
539. Какая разница между IPv4 и IPv6?
540. Сколько памяти необходимо для хранения IPv4?
541. Зачем порт?
542. Сколько максимально может быть портов?
543. Какая разница между TCP и UDP?
544. Для чего такой ненадежный UDP-протокол?
545. Что такое менеджер пакетов?
546. Какие бывают менеджеры пакетов?
547. Какие бывают дистрибутивы Linux?
548. Что такое PID?
549. Для чего используют файловые дескрипторы?
550. Расскажите о стандартных файловых дескрипторах процесса.
551. Что такое Pipe?
552. Что такое Named Pipe?
553. Что такое UID?
554. Расскажите о командах bash.
555. Какие есть виды SCM?
556. Для чего используют системы контроля версий?
557. Какие есть команды git?
558. Какие этапы во время коммита изменений?
559. Разница между git fetch и git pull?
560. Какие есть этапы решения merge conflict?
561. Посчитайте количество единиц в произвольном числе.
562. Структура по типу «односвязный список». Напишите функцию, которая разворачивает список. То есть первый элемент становится последним, а последний — первым.
563. Напишите реализацию функции int atoi(const char * str); преобразования строки в число.
564. Для структуры типа односвязный список напишите функцию вставки элемента.
565. Реализуйте класс vector.
566. Реализуйте бинарный поиск в массиве.
567. Реализуйте любую сортировку.
568. Реализуйте макрос для сравнения двух строк.
569. Реализуйте реверс строк.
570. Реализуйте перевода числа из строки в int.
571. Реализуйте подсчет слов в предложении.
572. Реализуйте подсчет чисел Фибоначчи.
573. Найдите такие элементы двух массивов, которые встречаются только в каждом из них. Желательно использовать STL.
574. Удалите из unordered_map элементы, которые делятся на 2, и выведите ключи этих элементов.
575. Напишите класс для логирования, который мог бы логировать в консоль или файл.
576. Напишите функцию для определения, является ли указанный год високосным.
577. Напишите функцию для определения, является ли заданное слово палиндромом.
578. Напишите реализацию паттерна Singleton.
579. Напишите реализацию std::vector с операциями: push_back, push_front, pop_back, pop_front, size, clear.
580. Напишите рекурсивный поиск значения в дереве бинарного поиска.
581. Напишите функцию, которая проверяет, является ли дерево сбалансированным.
582. Напишите функцию для поиска уникального элемента в массиве.
583. Какие курсы прошли или книги прочитали за этот год? Чему научились?
584. Что нравится и не нравится в С++? Чего не хватает?
585. Что интересного нашли в новых стандартах С++ 17 С++ 20 (конкретные фичи)?
586. Расскажите о фичах, которые появились в разных версиях языка.
587. Расскажите о модели памяти, которая появилась в стандарте С++ 11.
588. Что такое сериализация? Какие библиотеки знаете?
589. Какие знаете паттерны проектирования?
590. Что такое операционная система? Какие существуют типы по назначению?
591. Назовите основные составляющие и принципы работы ОС Linux в качестве примера системы общего назначения.
592. Что такое SFINAE и PIMPL?
593. Назовите порождающие, структурные и поведенческие паттерны программирования и приведите примеры их использования.
594. Расскажите о системах автоматизации билд-процесса.
595. В чем разница между статической и динамической библиотеками?
596. В чем разница между исполнительным файлом и динамичной библиотекой?
597. Что такое DLL hell?
598. Что такое флажки компиляции (fPIC)?
599. В чем разница между дебажной и релизной сборками?
600. Что нужно для использования сторонней библиотеки?
601. Что такое internal linkage?
602. Что будет, если дважды вызвать free?
603. Как происходит вызов функции?
604. Как происходит передача параметров в функцию?
605. Как обрабатывается константность переменных?
606. Что означает ключевое слово inline?
607. Для чего используют выравнивания, можно ли его контролировать?
608. Расскажите о битовых полях.
609. Для чего нужен extern «C»?
610. Что будет, если в двух файлах сделать функцию с одинаковым именем и параметрами? На каком этапе возникнет ошибка?
611. Как экспортировать / импортировать функции из динамической библиотеки?
612. Какая разница между С-style приведением типов и C++ приведением?
613. Что такое явное и неявное приведение типов в С++? Зачем делать explicit-конструктор?
614. Что такое Uniform initialization? Aggregate initialization?
615. Что такое Reference to temporary object? Как продлить время жизни временного объекта?
616. Что такое делегирующий конструктор?
617. Что такое список инициализации?
618. Каков порядок инициализации полей класса? Что случится, если конструктор инициализирует поля в другом порядке?
619. Что случится, если инициализировать поле другим полем?
620. Что такое copy elision? Сколько раз будет вызван конструктор / деструктор у объекта, который возвращают по значению?
621. Что такое move-семантика?
622. В каких случаях будет сгенерирован конструктор копирования?
623. Чем отличается конструктор копирования от оператора присваивания?
624. При каких условиях в конструкторе можно выбросить exception?
625. Что такое конструктор по умолчанию? Для чего нужны default и delete?
626. Чем отличается интерфейс от абстрактного класса?
627. Какие виды полиморфизма в С++?
628. Как реализовано наследование в большинстве компиляторов?
629. Множественное наследование: за и против.
630. Виртуальное наследование и порядок конструирования.
631. Зачем использовать override?
632. Какие есть правила вывода типа при использовании auto? В каких случаях auto может привести к нежелательному копирования объекта?
633. Расскажите обо всех возможных способах использования ключевого слова static в С++. Что такое static initialization order fiasco?
634. Что делает вызов throw; в блоке catch?
635. Чем отличается constexpr от const?
636. Что такое const correctness?
637. В каком случае можно использовать const_cast?
638. Что такое ключевое слово mutable и когда его нужно использовать?
639. Что такое ключевое слово friend и когда его нужно использовать?
640. Расскажите о лямбда-выражениях в С++ и доступе к переменным во внешней области видимости, захвате this в лямбду и времени жизни лямбды и захваченных переменных.
641. Что такое функтор? Напишите пример.
642. Что такое специализация шаблона?
643. Что такое dynamic_cast и run-time type identification?
644. Что такое exception? Как бросить и поймать?
645. Что будет, если бросить exception из конструктора? А из деструктора?
646. Что будет, если не поймать exception?
647. Что произойдет, если exception выйдет за пределы блока noexcept функции?
648. Для чего можно использовать приватное наследование?
649. Что такое контракт функции?
650. Что такое vptr и vtable?
651. Где содержится vptr?
652. Где содержится vtable?
653. Какая разница между overload и override?
654. Как компилятор различает члены класса и обычные переменные в функциях?
655. Зачем используют exceptions?
656. Что такое блоки try-throw-catch?
657. Расскажите о логике catch-блоков.
658. Что такое move constructor?
659. В чем разница между константным методом и неконстантным?
660. Что такое О-нотация и как определить сложность любого алгоритма?
661. Что такое таблица виртуальных методов?
662. Какие функции класса автоматически генерирует компилятор, если их определить?
663. Что такое выравнивание данных?
664. Что такое exception?
665. Какие есть стандартные контейнеры и на основе каких структур они построены?
666. Что такое Undefined behavior? Приведите примеры.
667. Как определить, что в программе есть memory leak?
668. Для чего нужен std::make_shared? Чем он лучше создания std::shared_ptr через конструктор?
669. Что будет, если выделить один объем памяти, а записать больше?
670. Что такое переполнение stack?
671. Зачем нужны паттерны? Какие типы паттернов различают?
672. Недостатки паттерна Singleton. Когда он уместен?
673. Преимущества и недостатки PIMPL.
674. В чем разница между паттерн-фабрикой и фабричным методом? Когда использовать какой из них?
675. Что такое паттерн Observer?
676. Как контролировать состояние программы? Машину состояний? Паттерн состояние?
677. Что такое паттерн Visitor?
678. Какие есть правила вывода типа в шаблоне?
679. Чем отличается using от typedef?
680. Сколько памяти занимает произвольная структура? Что такое выравнивание объекта?
681. Почему пустая структура занимает 1 байт? Какая минимальная единица адресации в С++?
682. Что такое SOLID? Что означает каждый из этих принципов?
683. Расскажите о паттернах проектирования.
684. Что такое Dependency Injection? Приведите пример.
685. Какие преимущества и недостатки функционального подхода?
686. Что такое принцип RAII?
687. Что такое принцип DRY?
688. Что такое принцип KISS?
689. Какие преимущества композиции перед наследованием?
690. Какие алгоритмы с STL использовали? Каких не хватает?
691. Какими особенностями должен обладать класс, чтобы он был итератором?
692. Какие бывают итераторы?
693. Расскажите о инвалидации итераторов.
694. Как оптимизировать удаление элемента из середины вектора?
695. Как реализован vector?
696. Как реализован list?
697. Как расширить STL-контейнеры?
698. Какие есть алгоритмы в STL?
699. В чем разница между vector, deque, list, set e STL?
700. Когда надо использовать map? Когда — unordered_map? Какова сложность поиска и вставки в этих контейнерах?
701. Как проверить, есть ли в контейнере элементы? Почему вызов container.size() является плохой практикой?
702. Что такое exception safety guarantee? Какую exception safety guarantee имеют STL-контейнеры?
703. Расскажите о типах умных указателей и подсчете ссылок в них.
704. Является ли С++ thread-safe?
705. В чем разница между многопоточностью и асинхронностью?
706. Что такое многопоточность? Какую функциональность предоставляет С++ для разработки многопоточных приложений? Каковы основные проблемы многопоточных приложений?
707. Как передать информацию между несколькими процессами?
708. Как синхронизировать между собой несколько процессов?
709. Какие есть особенности работы с shared memory?
710. Как работает spinlock?
711. Какие вы знаете особенности использования recursive mutex?
712. Расскажите о read-write mutex.
713. Что такое race-condition? Взаимная блокировка? Что такое критическая секция?
714. Какие избежать состояния гонки?
715. Чем отличается мьютекс от семафора?
716. Какие примитивы синхронизации реализованы в C++? Преимущества lock_guard?
717. Что случится, если exception выйдет за пределы потока? Какие инструменты есть для безопасной асинхронности в С++?
718. Чем отличается std::launch::async от std::launch::deferred?
719. Что такое атомарная операция? std::atomic?
720. Как работать с std::conditional_variable?
721. Как создать поток с помощью std::thread?
722. На сколько потоков лучше разбить задачу? От чего это зависит?
723. Как работать с std::async?
724. Thread-safe гарантии контейнеров в С++. В чем недостаток интерфейса front() + pop_fornt()?
725. Что такое TCP handshake?
726. В чем разница между TCP и UDP?
727. Расскажите о протоколах верхнего уровня.
728. В чем разница между HTTP и HTTPS?
729. Расскажите о SSL/TLS handshake.
730. Расскажите о процессах CI.
731. Как отредактировать коммит?
732. Расскажите об интерактивном rebase.
733. Какие могут быть способы дебаггинга кода?
734. Для чего нужны Unit test? Чем они отличаются от Functional Test?
735. Как тестировать код? Какой фреймворк используете?
736. Какие библиотеки знаете для написания тестов?
737. Что такое mock?
738. Сколько тестов нужно написать на одну функцию?
739. Что такое побочный эффект, идемпотентность и чистые функции?
740. Что такое контейнеризация и в чем ее преимущества и недостатки? Что такое Docker или иной инструмент контейнеризации?
741. Что такое CI/CD и какие преимущества дает разработчику?
742. Каковы принципы итеративных методологий?
743. Какие преимущества и недостатки code-convention?
744. Напишите максимально корректную реализацию класса string с конструктором копирования и оператором присваивания.
745. Напишите реализацию очереди.
746. Реализуйте функцию, которая за один проход найдет уникальный элемент в контейнере.
747. Напишите thread-safe пул потоков.
748. Напишите игру «Жизнь» в ООП-стиле.
749. Напишите класс, который получает из базы список товаров по фильтру и показывает на консоли. Напишите тесты для него.
750. Любая задача на написание кода, чтобы проверить умение проектировать интерфейсы и придерживаться принципов SOLID, DRY, KISS.
751. Напишите свою реализацию std::atomic.
752. Напишите программу для анализа графов: нахождение циклов, deadlock-состояний, циклов, недоступных состояний.
753. Напишите программу, проверяющую, что в системе запущен только один ее экземпляр. Решение должно быть cross-platform.
754. Проанализируйте C++ код с точки зрения качества: выявить потенциальные memory leak, нерациональное использование STL-контейнеров, алгоритмов, неоптимальные конструкции и тому подобное.
755. Напишите код для решения судоку.
756. Напишите код, который найдет зацикливание в односвязном списке.
757. Как вы понимаете SOLID?
758. Как разработать систему плагинов на С++?
759. Что такое RPC? Какие библиотеки знаете?
760. На что обращать внимание при проведении code review?
761. Какие есть проблемы при написании кроссплатформенного кода? На что обращать внимание?
762. Что делать, если код работает медленно?
763. Какие есть способы и методология измерения быстродействия кода? Как можно устранить / уменьшить влияние замеров на быстродействие?
764. Что такое SFINAE? Для чего используется?
765. Что такое метапрограммирование? С помощью чего реализуется на С++?
766. Как использовать variadic templates?
767. Как тестировать закрытые методы?
768. Как считать покрытие тестами? Нужно ли это делать?
769. Что такое cache miss и как это выявить?
770. Что такое SIMD-инструкции? Каковы необходимые условия и способы их использования?
771. Что такое покрытие кода и как оно обеспечивается?
772. Опишите принципы lock-free структур данных и свой опыт работы с ними.
773. Расскажите о построении билд-системы.
774. Как работать с билд-системами: Make, CMake.
775. Как интегрировать third-party в проект?
776. Что такое барьеры памяти?
777. Расскажите о работе с сырыми указателями и ручном управлении памятью.
778. Что такое статический анализатор кода? Какие знаете?
779. Что такое динамический анализатор кода? Какие знаете?
780. Проект медленно собирается. Как можно ускорить?
781. Расскажите об использовании realloc в контейнерах.
782. Как работают шаблоны?
783. Расскажите о специализации шаблонов.
784. Как работает RTTI?
785. Можно ли использовать exception в конструкторе / деструкторе?
786. Что такое rvalue и lvalue?
787. В чем особенности контейнеров std::set, std::map, std::unordered_map, std::hash?
788. Что такое placement new? Для чего используют? Как сделать placement delete?
789. Как размещается в памяти класс с множественным наследованием и виртуальными функциями?
790. Как работают точки останова?
791. Что такое уязвимости? Механизм их работы?
792. Как написать собственный std::shared_ptr?
793. Что такое curiously recurring template pattern?
794. Опишите назначение и принцип работы std::shared_ptr, std::unique_ptr и std::weak_ptr.
795. Каково назначение и различия использования std::variant и std::any?
796. Какие улучшения получил std::search в С++ 17?
797. Что такое copy elision и когда становится возможным? Какие особенности для разных стандартов?
798. Что такое Return Value Optimization?
799. Поясните принципы SOLID.
800. Поясните принципы KISS.
801. Поясните принципы YAGNI.
802. Какие есть подходы к оптимизации кода?
803. На что стоит обращать внимание при code review?
804. Какие есть паттерны проектирования? Почему не советуют использовать Singleton?
805. Что такое статический полиморфизм?
806. Когда std::vector может использовать std::move?
807. Расскажите о своем любимом алгоритме поиска.
808. Что такое lock-free и wait-free алгоритмы? В чем их отличия и способы реализации?
809. Опишите назначения execution policy для параллельных алгоритмов.
810. Расскажите о построении API, рассчитанных на многопоточное использование.
811. В чем разница между kernel-level и user-level потоками?
812. Что такое coroutine?
813. Что делает спецификатор thread_local?
814. Как реализовать синхронизацию в задаче producer-consumer?
815. Как синхронизироваться между различными процессами?
816. Расскажите о настройке процесса менеджмента ветвей репозитория.
817. Расскажите о стратегии ветвления.
818. Напишите базовую реализацию std::shared_ptr.
819. Реализуйте алгоритм сортировки.
820. Реализуйте алгоритм хеширования.
821. Реализуйте shared_ptr с расширением для weak_ptr.
822. Реализуйте простейший producer-consumer, используя условные переменные.
823. Опишите как можно подробнее, что происходит в системе, когда приложение делает сетевой запрос.
824. Детально описать дизайн программного компонента, например, системы голосования — учесть при этом высокую нагрузку и сделать его расширяемым и отказоустойчивым.
